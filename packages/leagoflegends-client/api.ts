/* tslint:disable */
/* eslint-disable */
/**
 * LoLClient
 * League of Legends Game Client
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Ability Resource
 * @export
 * @enum {string}
 */

export enum LoLAbilityResourceModel {
    mana = 'MANA',
    energy = 'ENERGY',
    none = 'NONE',
    shield = 'SHIELD',
    battlefury = 'BATTLEFURY',
    dragonfury = 'DRAGONFURY',
    rage = 'RAGE',
    heat = 'HEAT',
    gnarfury = 'GNARFURY',
    ferocity = 'FEROCITY',
    bloodwell = 'BLOODWELL',
    wind = 'WIND',
    ammo = 'AMMO',
    moonlight = 'MOONLIGHT',
    other = 'OTHER',
    max = 'MAX'
}


/**
 * Represents a cancelled asynchronous operation.
 * @export
 * @interface LoLBindingAsyncCancelEventModel
 */
export interface LoLBindingAsyncCancelEventModel {
    /**
     * Asynchronous operation token
     * @type {number}
     * @memberof LoLBindingAsyncCancelEventModel
     */
    'asyncToken'?: number;
}
/**
 * Represents a failed asynchronous operation.
 * @export
 * @interface LoLBindingAsyncFailureEventModel
 */
export interface LoLBindingAsyncFailureEventModel {
    /**
     * Asynchronous operation token
     * @type {number}
     * @memberof LoLBindingAsyncFailureEventModel
     */
    'asyncToken'?: number;
    /**
     * Error message
     * @type {string}
     * @memberof LoLBindingAsyncFailureEventModel
     */
    'error'?: string;
}
/**
 * Possible states of an asynchronous operation.
 * @export
 * @enum {string}
 */

export enum LoLBindingAsyncStateModel {
    none = 'None',
    running = 'Running',
    cancelling = 'Cancelling',
    cancelled = 'Cancelled',
    succeeded = 'Succeeded',
    failed = 'Failed'
}


/**
 * Represents the parameters of a call to a provided callback.
 * @export
 * @interface LoLBindingCallbackEventModel
 */
export interface LoLBindingCallbackEventModel {
    /**
     * ID of the callback being invoked
     * @type {number}
     * @memberof LoLBindingCallbackEventModel
     */
    'id'?: number;
    /**
     * Callback parameters
     * @type {Array<{ [key: string]: any | undefined; }>}
     * @memberof LoLBindingCallbackEventModel
     */
    'parameters'?: Array<{ [key: string]: any | undefined; }>;
}
/**
 * Describes the exposed native API.
 * @export
 * @interface LoLBindingFullApiHelpModel
 */
export interface LoLBindingFullApiHelpModel {
    /**
     * 
     * @type {Array<LoLBindingFullEventHelpModel>}
     * @memberof LoLBindingFullApiHelpModel
     */
    'events'?: Array<LoLBindingFullEventHelpModel>;
    /**
     * 
     * @type {Array<LoLBindingFullFunctionHelpModel>}
     * @memberof LoLBindingFullApiHelpModel
     */
    'functions'?: Array<LoLBindingFullFunctionHelpModel>;
    /**
     * 
     * @type {Array<LoLBindingFullTypeHelpModel>}
     * @memberof LoLBindingFullApiHelpModel
     */
    'types'?: Array<LoLBindingFullTypeHelpModel>;
}
/**
 * Describes a function parameter.
 * @export
 * @interface LoLBindingFullArgumentHelpModel
 */
export interface LoLBindingFullArgumentHelpModel {
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullArgumentHelpModel
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullArgumentHelpModel
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoLBindingFullArgumentHelpModel
     */
    'optional'?: boolean;
    /**
     * 
     * @type {LoLBindingFullTypeIdentifierModel}
     * @memberof LoLBindingFullArgumentHelpModel
     */
    'type'?: LoLBindingFullTypeIdentifierModel;
}
/**
 * Describes an enumerator.
 * @export
 * @interface LoLBindingFullEnumValueHelpModel
 */
export interface LoLBindingFullEnumValueHelpModel {
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullEnumValueHelpModel
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullEnumValueHelpModel
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoLBindingFullEnumValueHelpModel
     */
    'value'?: number;
}
/**
 * Describes an event.
 * @export
 * @interface LoLBindingFullEventHelpModel
 */
export interface LoLBindingFullEventHelpModel {
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullEventHelpModel
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullEventHelpModel
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullEventHelpModel
     */
    'nameSpace'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoLBindingFullEventHelpModel
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {LoLBindingFullTypeIdentifierModel}
     * @memberof LoLBindingFullEventHelpModel
     */
    'type'?: LoLBindingFullTypeIdentifierModel;
}
/**
 * Describes a member of a struct.
 * @export
 * @interface LoLBindingFullFieldHelpModel
 */
export interface LoLBindingFullFieldHelpModel {
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullFieldHelpModel
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullFieldHelpModel
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoLBindingFullFieldHelpModel
     */
    'offset'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LoLBindingFullFieldHelpModel
     */
    'optional'?: boolean;
    /**
     * 
     * @type {LoLBindingFullTypeIdentifierModel}
     * @memberof LoLBindingFullFieldHelpModel
     */
    'type'?: LoLBindingFullTypeIdentifierModel;
}
/**
 * Describes a function.
 * @export
 * @interface LoLBindingFullFunctionHelpModel
 */
export interface LoLBindingFullFunctionHelpModel {
    /**
     * 
     * @type {Array<LoLBindingFullArgumentHelpModel>}
     * @memberof LoLBindingFullFunctionHelpModel
     */
    'arguments'?: Array<LoLBindingFullArgumentHelpModel>;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullFunctionHelpModel
     */
    'async'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullFunctionHelpModel
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullFunctionHelpModel
     */
    'help'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullFunctionHelpModel
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullFunctionHelpModel
     */
    'nameSpace'?: string;
    /**
     * 
     * @type {LoLBindingFullTypeIdentifierModel}
     * @memberof LoLBindingFullFunctionHelpModel
     */
    'returns'?: LoLBindingFullTypeIdentifierModel;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoLBindingFullFunctionHelpModel
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof LoLBindingFullFunctionHelpModel
     */
    'threadSafe'?: boolean;
}
/**
 * Describes a struct or enum type.
 * @export
 * @interface LoLBindingFullTypeHelpModel
 */
export interface LoLBindingFullTypeHelpModel {
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullTypeHelpModel
     */
    'description'?: string;
    /**
     * 
     * @type {Array<LoLBindingFullFieldHelpModel>}
     * @memberof LoLBindingFullTypeHelpModel
     */
    'fields'?: Array<LoLBindingFullFieldHelpModel>;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullTypeHelpModel
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullTypeHelpModel
     */
    'nameSpace'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoLBindingFullTypeHelpModel
     */
    'size'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoLBindingFullTypeHelpModel
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<LoLBindingFullEnumValueHelpModel>}
     * @memberof LoLBindingFullTypeHelpModel
     */
    'values'?: Array<LoLBindingFullEnumValueHelpModel>;
}
/**
 * Describes the type of a value.
 * @export
 * @interface LoLBindingFullTypeIdentifierModel
 */
export interface LoLBindingFullTypeIdentifierModel {
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullTypeIdentifierModel
     */
    'elementType'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoLBindingFullTypeIdentifierModel
     */
    'type'?: string;
}
/**
 * Represents generic data for an asynchronous event.
 * @export
 * @interface LoLBindingGenericAsyncEventModel
 */
export interface LoLBindingGenericAsyncEventModel {
    /**
     * Asynchronous operation token
     * @type {number}
     * @memberof LoLBindingGenericAsyncEventModel
     */
    'asyncToken'?: number;
    /**
     * Event data
     * @type {{ [key: string]: any | undefined; }}
     * @memberof LoLBindingGenericAsyncEventModel
     */
    'data'?: { [key: string]: any | undefined; };
}
/**
 * Represents generic data for an event.
 * @export
 * @interface LoLBindingGenericEventModel
 */
export interface LoLBindingGenericEventModel {
    /**
     * Event data
     * @type {{ [key: string]: any | undefined; }}
     * @memberof LoLBindingGenericEventModel
     */
    'data'?: { [key: string]: any | undefined; };
}
/**
 * Help format for binding functions and types.
 * @export
 * @enum {string}
 */

export enum LoLBindingHelpFormatModel {
    full = 'Full',
    epytext = 'Epytext'
}


/**
 * Color
 * @export
 * @interface LoLColorModel
 */
export interface LoLColorModel {
    /**
     * 
     * @type {number}
     * @memberof LoLColorModel
     */
    'a'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoLColorModel
     */
    'b'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoLColorModel
     */
    'g'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoLColorModel
     */
    'r'?: number;
}
/**
 * Help format for remoting functions and types.
 * @export
 * @enum {string}
 */

export enum LoLRemotingHelpFormatModel {
    full = 'Full',
    epytext = 'Epytext',
    brief = 'Brief',
    console = 'Console'
}


/**
 * Well-known privilege levels for bindable functions.
 * @export
 * @enum {string}
 */

export enum LoLRemotingPrivilegeModel {
    none = 'None',
    user = 'User',
    admin = 'Admin',
    local = 'Local'
}


/**
 * Serialization format for remoting requests and results.
 * @export
 * @enum {string}
 */

export enum LoLRemotingSerializedFormatModel {
    json = 'JSON',
    yaml = 'YAML',
    msgPack = 'MsgPack'
}


/**
 * Team identification
 * @export
 * @enum {string}
 */

export enum LoLTeamIDModel {
    unknown = 'UNKNOWN',
    order = 'ORDER',
    chaos = 'CHAOS',
    neutral = 'NEUTRAL'
}


/**
 * 2D vector
 * @export
 * @interface LoLVector2fModel
 */
export interface LoLVector2fModel {
    /**
     * 
     * @type {number}
     * @memberof LoLVector2fModel
     */
    'x'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoLVector2fModel
     */
    'y'?: number;
}
/**
 * 3D vector
 * @export
 * @interface LoLVector3fModel
 */
export interface LoLVector3fModel {
    /**
     * 
     * @type {number}
     * @memberof LoLVector3fModel
     */
    'x'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoLVector3fModel
     */
    'y'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoLVector3fModel
     */
    'z'?: number;
}
/**
 * 4D vector
 * @export
 * @interface LoLVector4fModel
 */
export interface LoLVector4fModel {
    /**
     * 
     * @type {number}
     * @memberof LoLVector4fModel
     */
    'w'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoLVector4fModel
     */
    'x'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoLVector4fModel
     */
    'y'?: number;
    /**
     * 
     * @type {number}
     * @memberof LoLVector4fModel
     */
    'z'?: number;
}

/**
 * AbilitiesApi - axios parameter creator
 * @export
 */
export const AbilitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Abilities for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayerabilities: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/activeplayerabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AbilitiesApi - functional programming interface
 * @export
 */
export const AbilitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AbilitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Abilities for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataActiveplayerabilities(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataActiveplayerabilities(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbilitiesApi.getLiveclientdataActiveplayerabilities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AbilitiesApi - factory interface
 * @export
 */
export const AbilitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AbilitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Abilities for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayerabilities(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataActiveplayerabilities(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AbilitiesApi - interface
 * @export
 * @interface AbilitiesApi
 */
export interface AbilitiesApiInterface {
    /**
     * 
     * @summary Get Abilities for the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbilitiesApiInterface
     */
    getLiveclientdataActiveplayerabilities(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

}

/**
 * AbilitiesApi - object-oriented interface
 * @export
 * @class AbilitiesApi
 * @extends {BaseAPI}
 */
export class AbilitiesApi extends BaseAPI implements AbilitiesApiInterface {
    /**
     * 
     * @summary Get Abilities for the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbilitiesApi
     */
    public getLiveclientdataActiveplayerabilities(options?: RawAxiosRequestConfig) {
        return AbilitiesApiFp(this.configuration).getLiveclientdataActiveplayerabilities(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ActivePlayerApi - axios parameter creator
 * @export
 */
export const ActivePlayerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all data about the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayer: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/activeplayer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Abilities for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayerabilities: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/activeplayerabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the player name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayername: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/activeplayername`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the full list of runes for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayerrunes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/activeplayerrunes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivePlayerApi - functional programming interface
 * @export
 */
export const ActivePlayerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivePlayerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all data about the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataActiveplayer(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataActiveplayer(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivePlayerApi.getLiveclientdataActiveplayer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Abilities for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataActiveplayerabilities(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataActiveplayerabilities(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivePlayerApi.getLiveclientdataActiveplayerabilities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the player name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataActiveplayername(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataActiveplayername(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivePlayerApi.getLiveclientdataActiveplayername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the full list of runes for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataActiveplayerrunes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataActiveplayerrunes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivePlayerApi.getLiveclientdataActiveplayerrunes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivePlayerApi - factory interface
 * @export
 */
export const ActivePlayerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivePlayerApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all data about the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayer(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataActiveplayer(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Abilities for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayerabilities(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataActiveplayerabilities(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the player name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayername(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getLiveclientdataActiveplayername(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the full list of runes for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayerrunes(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataActiveplayerrunes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivePlayerApi - interface
 * @export
 * @interface ActivePlayerApi
 */
export interface ActivePlayerApiInterface {
    /**
     * 
     * @summary Get all data about the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivePlayerApiInterface
     */
    getLiveclientdataActiveplayer(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Get Abilities for the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivePlayerApiInterface
     */
    getLiveclientdataActiveplayerabilities(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Returns the player name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivePlayerApiInterface
     */
    getLiveclientdataActiveplayername(options?: RawAxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Retrieve the full list of runes for the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivePlayerApiInterface
     */
    getLiveclientdataActiveplayerrunes(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

}

/**
 * ActivePlayerApi - object-oriented interface
 * @export
 * @class ActivePlayerApi
 * @extends {BaseAPI}
 */
export class ActivePlayerApi extends BaseAPI implements ActivePlayerApiInterface {
    /**
     * 
     * @summary Get all data about the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivePlayerApi
     */
    public getLiveclientdataActiveplayer(options?: RawAxiosRequestConfig) {
        return ActivePlayerApiFp(this.configuration).getLiveclientdataActiveplayer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Abilities for the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivePlayerApi
     */
    public getLiveclientdataActiveplayerabilities(options?: RawAxiosRequestConfig) {
        return ActivePlayerApiFp(this.configuration).getLiveclientdataActiveplayerabilities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the player name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivePlayerApi
     */
    public getLiveclientdataActiveplayername(options?: RawAxiosRequestConfig) {
        return ActivePlayerApiFp(this.configuration).getLiveclientdataActiveplayername(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the full list of runes for the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivePlayerApi
     */
    public getLiveclientdataActiveplayerrunes(options?: RawAxiosRequestConfig) {
        return ActivePlayerApiFp(this.configuration).getLiveclientdataActiveplayerrunes(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AllApi - axios parameter creator
 * @export
 */
export const AllApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all available data
         * @param {} [UNKNOWN_PARAMETER_NAME] ID of the next event you expect to see
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataAllgamedata: async (UNKNOWN_PARAMETER_NAME?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/allgamedata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['eventID'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllApi - functional programming interface
 * @export
 */
export const AllApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AllApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all available data
         * @param {} [UNKNOWN_PARAMETER_NAME] ID of the next event you expect to see
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataAllgamedata(UNKNOWN_PARAMETER_NAME?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataAllgamedata(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllApi.getLiveclientdataAllgamedata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AllApi - factory interface
 * @export
 */
export const AllApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AllApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all available data
         * @param {AllApiGetLiveclientdataAllgamedataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataAllgamedata(requestParameters: AllApiGetLiveclientdataAllgamedataRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataAllgamedata(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AllApi - interface
 * @export
 * @interface AllApi
 */
export interface AllApiInterface {
    /**
     * 
     * @summary Get all available data
     * @param {AllApiGetLiveclientdataAllgamedataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllApiInterface
     */
    getLiveclientdataAllgamedata(requestParameters?: AllApiGetLiveclientdataAllgamedataRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

}

/**
 * Request parameters for getLiveclientdataAllgamedata operation in AllApi.
 * @export
 * @interface AllApiGetLiveclientdataAllgamedataRequest
 */
export interface AllApiGetLiveclientdataAllgamedataRequest {
    /**
     * ID of the next event you expect to see
     * @type {}
     * @memberof AllApiGetLiveclientdataAllgamedata
     */
    readonly UNKNOWN_PARAMETER_NAME?: any;
}

/**
 * AllApi - object-oriented interface
 * @export
 * @class AllApi
 * @extends {BaseAPI}
 */
export class AllApi extends BaseAPI implements AllApiInterface {
    /**
     * 
     * @summary Get all available data
     * @param {AllApiGetLiveclientdataAllgamedataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllApi
     */
    public getLiveclientdataAllgamedata(requestParameters: AllApiGetLiveclientdataAllgamedataRequest = {}, options?: RawAxiosRequestConfig) {
        return AllApiFp(this.configuration).getLiveclientdataAllgamedata(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AllPlayersApi - axios parameter creator
 * @export
 */
export const AllPlayersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of items for the player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayeritems: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('getLiveclientdataPlayeritems', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/liveclientdata/playeritems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['riotId'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the list of heroes in the game and their stats
         * @param {} [UNKNOWN_PARAMETER_NAME] Heroes team ID. Optional, returns all players on all teams if null. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayerlist: async (UNKNOWN_PARAMETER_NAME?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/playerlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['teamID'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the basic runes of any player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayermainrunes: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('getLiveclientdataPlayermainrunes', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/liveclientdata/playermainrunes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['riotId'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the list of the current scores for the player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayerscores: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('getLiveclientdataPlayerscores', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/liveclientdata/playerscores`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['riotId'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the list of the summoner spells for the player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayersummonerspells: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('getLiveclientdataPlayersummonerspells', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/liveclientdata/playersummonerspells`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['riotId'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllPlayersApi - functional programming interface
 * @export
 */
export const AllPlayersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AllPlayersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of items for the player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataPlayeritems(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataPlayeritems(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllPlayersApi.getLiveclientdataPlayeritems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the list of heroes in the game and their stats
         * @param {} [UNKNOWN_PARAMETER_NAME] Heroes team ID. Optional, returns all players on all teams if null. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataPlayerlist(UNKNOWN_PARAMETER_NAME?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataPlayerlist(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllPlayersApi.getLiveclientdataPlayerlist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the basic runes of any player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataPlayermainrunes(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataPlayermainrunes(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllPlayersApi.getLiveclientdataPlayermainrunes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the list of the current scores for the player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataPlayerscores(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataPlayerscores(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllPlayersApi.getLiveclientdataPlayerscores']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the list of the summoner spells for the player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataPlayersummonerspells(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataPlayersummonerspells(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllPlayersApi.getLiveclientdataPlayersummonerspells']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AllPlayersApi - factory interface
 * @export
 */
export const AllPlayersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AllPlayersApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of items for the player
         * @param {AllPlayersApiGetLiveclientdataPlayeritemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayeritems(requestParameters: AllPlayersApiGetLiveclientdataPlayeritemsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataPlayeritems(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the list of heroes in the game and their stats
         * @param {AllPlayersApiGetLiveclientdataPlayerlistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayerlist(requestParameters: AllPlayersApiGetLiveclientdataPlayerlistRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataPlayerlist(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the basic runes of any player
         * @param {AllPlayersApiGetLiveclientdataPlayermainrunesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayermainrunes(requestParameters: AllPlayersApiGetLiveclientdataPlayermainrunesRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataPlayermainrunes(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the list of the current scores for the player
         * @param {AllPlayersApiGetLiveclientdataPlayerscoresRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayerscores(requestParameters: AllPlayersApiGetLiveclientdataPlayerscoresRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataPlayerscores(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the list of the summoner spells for the player
         * @param {AllPlayersApiGetLiveclientdataPlayersummonerspellsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayersummonerspells(requestParameters: AllPlayersApiGetLiveclientdataPlayersummonerspellsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataPlayersummonerspells(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AllPlayersApi - interface
 * @export
 * @interface AllPlayersApi
 */
export interface AllPlayersApiInterface {
    /**
     * 
     * @summary Retrieve the list of items for the player
     * @param {AllPlayersApiGetLiveclientdataPlayeritemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllPlayersApiInterface
     */
    getLiveclientdataPlayeritems(requestParameters: AllPlayersApiGetLiveclientdataPlayeritemsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieve the list of heroes in the game and their stats
     * @param {AllPlayersApiGetLiveclientdataPlayerlistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllPlayersApiInterface
     */
    getLiveclientdataPlayerlist(requestParameters?: AllPlayersApiGetLiveclientdataPlayerlistRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieve the basic runes of any player
     * @param {AllPlayersApiGetLiveclientdataPlayermainrunesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllPlayersApiInterface
     */
    getLiveclientdataPlayermainrunes(requestParameters: AllPlayersApiGetLiveclientdataPlayermainrunesRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieve the list of the current scores for the player
     * @param {AllPlayersApiGetLiveclientdataPlayerscoresRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllPlayersApiInterface
     */
    getLiveclientdataPlayerscores(requestParameters: AllPlayersApiGetLiveclientdataPlayerscoresRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieve the list of the summoner spells for the player
     * @param {AllPlayersApiGetLiveclientdataPlayersummonerspellsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllPlayersApiInterface
     */
    getLiveclientdataPlayersummonerspells(requestParameters: AllPlayersApiGetLiveclientdataPlayersummonerspellsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

}

/**
 * Request parameters for getLiveclientdataPlayeritems operation in AllPlayersApi.
 * @export
 * @interface AllPlayersApiGetLiveclientdataPlayeritemsRequest
 */
export interface AllPlayersApiGetLiveclientdataPlayeritemsRequest {
    /**
     * RiotID GameName (with tag) of the player in the format Name#TAG
     * @type {}
     * @memberof AllPlayersApiGetLiveclientdataPlayeritems
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * Request parameters for getLiveclientdataPlayerlist operation in AllPlayersApi.
 * @export
 * @interface AllPlayersApiGetLiveclientdataPlayerlistRequest
 */
export interface AllPlayersApiGetLiveclientdataPlayerlistRequest {
    /**
     * Heroes team ID. Optional, returns all players on all teams if null. 
     * @type {}
     * @memberof AllPlayersApiGetLiveclientdataPlayerlist
     */
    readonly UNKNOWN_PARAMETER_NAME?: any;
}

/**
 * Request parameters for getLiveclientdataPlayermainrunes operation in AllPlayersApi.
 * @export
 * @interface AllPlayersApiGetLiveclientdataPlayermainrunesRequest
 */
export interface AllPlayersApiGetLiveclientdataPlayermainrunesRequest {
    /**
     * RiotID GameName (with tag) of the player in the format Name#TAG
     * @type {}
     * @memberof AllPlayersApiGetLiveclientdataPlayermainrunes
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * Request parameters for getLiveclientdataPlayerscores operation in AllPlayersApi.
 * @export
 * @interface AllPlayersApiGetLiveclientdataPlayerscoresRequest
 */
export interface AllPlayersApiGetLiveclientdataPlayerscoresRequest {
    /**
     * RiotID GameName (with tag) of the player in the format Name#TAG
     * @type {}
     * @memberof AllPlayersApiGetLiveclientdataPlayerscores
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * Request parameters for getLiveclientdataPlayersummonerspells operation in AllPlayersApi.
 * @export
 * @interface AllPlayersApiGetLiveclientdataPlayersummonerspellsRequest
 */
export interface AllPlayersApiGetLiveclientdataPlayersummonerspellsRequest {
    /**
     * RiotID GameName (with tag) of the player in the format Name#TAG
     * @type {}
     * @memberof AllPlayersApiGetLiveclientdataPlayersummonerspells
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * AllPlayersApi - object-oriented interface
 * @export
 * @class AllPlayersApi
 * @extends {BaseAPI}
 */
export class AllPlayersApi extends BaseAPI implements AllPlayersApiInterface {
    /**
     * 
     * @summary Retrieve the list of items for the player
     * @param {AllPlayersApiGetLiveclientdataPlayeritemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllPlayersApi
     */
    public getLiveclientdataPlayeritems(requestParameters: AllPlayersApiGetLiveclientdataPlayeritemsRequest, options?: RawAxiosRequestConfig) {
        return AllPlayersApiFp(this.configuration).getLiveclientdataPlayeritems(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the list of heroes in the game and their stats
     * @param {AllPlayersApiGetLiveclientdataPlayerlistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllPlayersApi
     */
    public getLiveclientdataPlayerlist(requestParameters: AllPlayersApiGetLiveclientdataPlayerlistRequest = {}, options?: RawAxiosRequestConfig) {
        return AllPlayersApiFp(this.configuration).getLiveclientdataPlayerlist(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the basic runes of any player
     * @param {AllPlayersApiGetLiveclientdataPlayermainrunesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllPlayersApi
     */
    public getLiveclientdataPlayermainrunes(requestParameters: AllPlayersApiGetLiveclientdataPlayermainrunesRequest, options?: RawAxiosRequestConfig) {
        return AllPlayersApiFp(this.configuration).getLiveclientdataPlayermainrunes(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the list of the current scores for the player
     * @param {AllPlayersApiGetLiveclientdataPlayerscoresRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllPlayersApi
     */
    public getLiveclientdataPlayerscores(requestParameters: AllPlayersApiGetLiveclientdataPlayerscoresRequest, options?: RawAxiosRequestConfig) {
        return AllPlayersApiFp(this.configuration).getLiveclientdataPlayerscores(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the list of the summoner spells for the player
     * @param {AllPlayersApiGetLiveclientdataPlayersummonerspellsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllPlayersApi
     */
    public getLiveclientdataPlayersummonerspells(requestParameters: AllPlayersApiGetLiveclientdataPlayersummonerspellsRequest, options?: RawAxiosRequestConfig) {
        return AllPlayersApiFp(this.configuration).getLiveclientdataPlayersummonerspells(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BuiltinApi - axios parameter creator
 * @export
 */
export const BuiltinApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels the asynchronous operation or removes its completion status.
         * @param {} UNKNOWN_PARAMETER_NAME ID of the asynchronous operation to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncDelete: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('asyncDelete', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/AsyncDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['asyncToken'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the result of a completed asynchronous operation.
         * @param {} UNKNOWN_PARAMETER_NAME ID of the asynchronous operation to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncResult: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('asyncResult', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/AsyncResult`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['asyncToken'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves details on the current state of an asynchronous operation.
         * @param {} UNKNOWN_PARAMETER_NAME ID of the asynchronous operation to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncStatus: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('asyncStatus', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/AsyncStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['asyncToken'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attempts to cancel an asynchronous operation
         * @param {} UNKNOWN_PARAMETER_NAME Operation to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('cancel', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/Cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['asyncToken'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Closes the connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exit: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Exit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With no arguments, returns a list of all available functions and types along with a short description. If a function or type is specified, returns detailed information about it.
         * @summary Returns information on available functions and types
         * @param {} [UNKNOWN_PARAMETER_NAME] Name of the function or type to describe
         * @param {} [UNKNOWN_PARAMETER_NAME2] Format for returned information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        help: async (UNKNOWN_PARAMETER_NAME?: any, UNKNOWN_PARAMETER_NAME2?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Help`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['target'] = UNKNOWN_PARAMETER_NAME;
            }

            if (UNKNOWN_PARAMETER_NAME2 !== undefined) {
                localVarQueryParameter['format'] = UNKNOWN_PARAMETER_NAME2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the API declaration for a supported API
         * @param {} UNKNOWN_PARAMETER_NAME API to get a declaration for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpApiDeclarationV1: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('httpApiDeclarationV1', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/swagger/v1/api-docs/{api}`
                .replace(`{${"api"}}`, encodeURIComponent(String(UNKNOWN_PARAMETER_NAME)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the API documentation resource listing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpApiDocsV1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/swagger/v1/api-docs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the API documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpApiDocsV2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/swagger/v2/swagger.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the API documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpApiDocsV3: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/swagger/v3/openapi.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels the asynchronous operation or removes its completion status.
         * @param {} UNKNOWN_PARAMETER_NAME ID of the asynchronous operation to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpAsyncDelete: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('httpAsyncDelete', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/async/v1/status/{asyncToken}`
                .replace(`{${"asyncToken"}}`, encodeURIComponent(String(UNKNOWN_PARAMETER_NAME)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the result of a completed asynchronous operation.
         * @param {} UNKNOWN_PARAMETER_NAME ID of the asynchronous operation to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpAsyncResult: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('httpAsyncResult', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/async/v1/result/{asyncToken}`
                .replace(`{${"asyncToken"}}`, encodeURIComponent(String(UNKNOWN_PARAMETER_NAME)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves details on the current state of an asynchronous operation.
         * @param {} UNKNOWN_PARAMETER_NAME ID of the asynchronous operation to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpAsyncStatus: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('httpAsyncStatus', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/async/v1/status/{asyncToken}`
                .replace(`{${"asyncToken"}}`, encodeURIComponent(String(UNKNOWN_PARAMETER_NAME)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subscribes to a given event
         * @param {} UNKNOWN_PARAMETER_NAME Name of the event to subscribe to
         * @param {} [UNKNOWN_PARAMETER_NAME2] Desired format to receive events in. If unspecified, events will be sent in the active result format at the time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribe: async (UNKNOWN_PARAMETER_NAME: any, UNKNOWN_PARAMETER_NAME2?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('subscribe', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/Subscribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['eventName'] = UNKNOWN_PARAMETER_NAME;
            }

            if (UNKNOWN_PARAMETER_NAME2 !== undefined) {
                localVarQueryParameter['format'] = UNKNOWN_PARAMETER_NAME2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unsubscribes from a given event
         * @param {} UNKNOWN_PARAMETER_NAME Name of the event to unsubscribe from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('unsubscribe', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/Unsubscribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['eventName'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuiltinApi - functional programming interface
 * @export
 */
export const BuiltinApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BuiltinApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancels the asynchronous operation or removes its completion status.
         * @param {} UNKNOWN_PARAMETER_NAME ID of the asynchronous operation to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async asyncDelete(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.asyncDelete(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.asyncDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves the result of a completed asynchronous operation.
         * @param {} UNKNOWN_PARAMETER_NAME ID of the asynchronous operation to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async asyncResult(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.asyncResult(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.asyncResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves details on the current state of an asynchronous operation.
         * @param {} UNKNOWN_PARAMETER_NAME ID of the asynchronous operation to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async asyncStatus(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.asyncStatus(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.asyncStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Attempts to cancel an asynchronous operation
         * @param {} UNKNOWN_PARAMETER_NAME Operation to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.cancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Closes the connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exit(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exit(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.exit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * With no arguments, returns a list of all available functions and types along with a short description. If a function or type is specified, returns detailed information about it.
         * @summary Returns information on available functions and types
         * @param {} [UNKNOWN_PARAMETER_NAME] Name of the function or type to describe
         * @param {} [UNKNOWN_PARAMETER_NAME2] Format for returned information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async help(UNKNOWN_PARAMETER_NAME?: any, UNKNOWN_PARAMETER_NAME2?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.help(UNKNOWN_PARAMETER_NAME, UNKNOWN_PARAMETER_NAME2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.help']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves the API declaration for a supported API
         * @param {} UNKNOWN_PARAMETER_NAME API to get a declaration for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpApiDeclarationV1(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpApiDeclarationV1(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.httpApiDeclarationV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves the API documentation resource listing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpApiDocsV1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpApiDocsV1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.httpApiDocsV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves the API documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpApiDocsV2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpApiDocsV2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.httpApiDocsV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves the API documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpApiDocsV3(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpApiDocsV3(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.httpApiDocsV3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancels the asynchronous operation or removes its completion status.
         * @param {} UNKNOWN_PARAMETER_NAME ID of the asynchronous operation to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpAsyncDelete(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpAsyncDelete(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.httpAsyncDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves the result of a completed asynchronous operation.
         * @param {} UNKNOWN_PARAMETER_NAME ID of the asynchronous operation to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpAsyncResult(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpAsyncResult(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.httpAsyncResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves details on the current state of an asynchronous operation.
         * @param {} UNKNOWN_PARAMETER_NAME ID of the asynchronous operation to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async httpAsyncStatus(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.httpAsyncStatus(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.httpAsyncStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subscribes to a given event
         * @param {} UNKNOWN_PARAMETER_NAME Name of the event to subscribe to
         * @param {} [UNKNOWN_PARAMETER_NAME2] Desired format to receive events in. If unspecified, events will be sent in the active result format at the time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribe(UNKNOWN_PARAMETER_NAME: any, UNKNOWN_PARAMETER_NAME2?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribe(UNKNOWN_PARAMETER_NAME, UNKNOWN_PARAMETER_NAME2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.subscribe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unsubscribes from a given event
         * @param {} UNKNOWN_PARAMETER_NAME Name of the event to unsubscribe from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribe(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribe(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuiltinApi.unsubscribe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BuiltinApi - factory interface
 * @export
 */
export const BuiltinApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BuiltinApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancels the asynchronous operation or removes its completion status.
         * @param {BuiltinApiAsyncDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncDelete(requestParameters: BuiltinApiAsyncDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.asyncDelete(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the result of a completed asynchronous operation.
         * @param {BuiltinApiAsyncResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncResult(requestParameters: BuiltinApiAsyncResultRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.asyncResult(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves details on the current state of an asynchronous operation.
         * @param {BuiltinApiAsyncStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        asyncStatus(requestParameters: BuiltinApiAsyncStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.asyncStatus(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attempts to cancel an asynchronous operation
         * @param {BuiltinApiCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(requestParameters: BuiltinApiCancelRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.cancel(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Closes the connection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exit(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.exit(options).then((request) => request(axios, basePath));
        },
        /**
         * With no arguments, returns a list of all available functions and types along with a short description. If a function or type is specified, returns detailed information about it.
         * @summary Returns information on available functions and types
         * @param {BuiltinApiHelpRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        help(requestParameters: BuiltinApiHelpRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.help(requestParameters.UNKNOWN_PARAMETER_NAME, requestParameters.UNKNOWN_PARAMETER_NAME2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the API declaration for a supported API
         * @param {BuiltinApiHttpApiDeclarationV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpApiDeclarationV1(requestParameters: BuiltinApiHttpApiDeclarationV1Request, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.httpApiDeclarationV1(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the API documentation resource listing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpApiDocsV1(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.httpApiDocsV1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the API documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpApiDocsV2(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.httpApiDocsV2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the API documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpApiDocsV3(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.httpApiDocsV3(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels the asynchronous operation or removes its completion status.
         * @param {BuiltinApiHttpAsyncDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpAsyncDelete(requestParameters: BuiltinApiHttpAsyncDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.httpAsyncDelete(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the result of a completed asynchronous operation.
         * @param {BuiltinApiHttpAsyncResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpAsyncResult(requestParameters: BuiltinApiHttpAsyncResultRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.httpAsyncResult(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves details on the current state of an asynchronous operation.
         * @param {BuiltinApiHttpAsyncStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        httpAsyncStatus(requestParameters: BuiltinApiHttpAsyncStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.httpAsyncStatus(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Subscribes to a given event
         * @param {BuiltinApiSubscribeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribe(requestParameters: BuiltinApiSubscribeRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.subscribe(requestParameters.UNKNOWN_PARAMETER_NAME, requestParameters.UNKNOWN_PARAMETER_NAME2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unsubscribes from a given event
         * @param {BuiltinApiUnsubscribeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe(requestParameters: BuiltinApiUnsubscribeRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.unsubscribe(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BuiltinApi - interface
 * @export
 * @interface BuiltinApi
 */
export interface BuiltinApiInterface {
    /**
     * 
     * @summary Cancels the asynchronous operation or removes its completion status.
     * @param {BuiltinApiAsyncDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    asyncDelete(requestParameters: BuiltinApiAsyncDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieves the result of a completed asynchronous operation.
     * @param {BuiltinApiAsyncResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    asyncResult(requestParameters: BuiltinApiAsyncResultRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieves details on the current state of an asynchronous operation.
     * @param {BuiltinApiAsyncStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    asyncStatus(requestParameters: BuiltinApiAsyncStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Attempts to cancel an asynchronous operation
     * @param {BuiltinApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    cancel(requestParameters: BuiltinApiCancelRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Closes the connection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    exit(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * With no arguments, returns a list of all available functions and types along with a short description. If a function or type is specified, returns detailed information about it.
     * @summary Returns information on available functions and types
     * @param {BuiltinApiHelpRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    help(requestParameters?: BuiltinApiHelpRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieves the API declaration for a supported API
     * @param {BuiltinApiHttpApiDeclarationV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    httpApiDeclarationV1(requestParameters: BuiltinApiHttpApiDeclarationV1Request, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieves the API documentation resource listing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    httpApiDocsV1(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieves the API documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    httpApiDocsV2(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieves the API documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    httpApiDocsV3(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Cancels the asynchronous operation or removes its completion status.
     * @param {BuiltinApiHttpAsyncDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    httpAsyncDelete(requestParameters: BuiltinApiHttpAsyncDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieves the result of a completed asynchronous operation.
     * @param {BuiltinApiHttpAsyncResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    httpAsyncResult(requestParameters: BuiltinApiHttpAsyncResultRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieves details on the current state of an asynchronous operation.
     * @param {BuiltinApiHttpAsyncStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    httpAsyncStatus(requestParameters: BuiltinApiHttpAsyncStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Subscribes to a given event
     * @param {BuiltinApiSubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    subscribe(requestParameters: BuiltinApiSubscribeRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Unsubscribes from a given event
     * @param {BuiltinApiUnsubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApiInterface
     */
    unsubscribe(requestParameters: BuiltinApiUnsubscribeRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

}

/**
 * Request parameters for asyncDelete operation in BuiltinApi.
 * @export
 * @interface BuiltinApiAsyncDeleteRequest
 */
export interface BuiltinApiAsyncDeleteRequest {
    /**
     * ID of the asynchronous operation to remove
     * @type {}
     * @memberof BuiltinApiAsyncDelete
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * Request parameters for asyncResult operation in BuiltinApi.
 * @export
 * @interface BuiltinApiAsyncResultRequest
 */
export interface BuiltinApiAsyncResultRequest {
    /**
     * ID of the asynchronous operation to check
     * @type {}
     * @memberof BuiltinApiAsyncResult
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * Request parameters for asyncStatus operation in BuiltinApi.
 * @export
 * @interface BuiltinApiAsyncStatusRequest
 */
export interface BuiltinApiAsyncStatusRequest {
    /**
     * ID of the asynchronous operation to check
     * @type {}
     * @memberof BuiltinApiAsyncStatus
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * Request parameters for cancel operation in BuiltinApi.
 * @export
 * @interface BuiltinApiCancelRequest
 */
export interface BuiltinApiCancelRequest {
    /**
     * Operation to cancel
     * @type {}
     * @memberof BuiltinApiCancel
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * Request parameters for help operation in BuiltinApi.
 * @export
 * @interface BuiltinApiHelpRequest
 */
export interface BuiltinApiHelpRequest {
    /**
     * Name of the function or type to describe
     * @type {}
     * @memberof BuiltinApiHelp
     */
    readonly UNKNOWN_PARAMETER_NAME?: any;

    /**
     * Format for returned information
     * @type {}
     * @memberof BuiltinApiHelp
     */
    readonly UNKNOWN_PARAMETER_NAME2?: any;
}

/**
 * Request parameters for httpApiDeclarationV1 operation in BuiltinApi.
 * @export
 * @interface BuiltinApiHttpApiDeclarationV1Request
 */
export interface BuiltinApiHttpApiDeclarationV1Request {
    /**
     * API to get a declaration for
     * @type {}
     * @memberof BuiltinApiHttpApiDeclarationV1
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * Request parameters for httpAsyncDelete operation in BuiltinApi.
 * @export
 * @interface BuiltinApiHttpAsyncDeleteRequest
 */
export interface BuiltinApiHttpAsyncDeleteRequest {
    /**
     * ID of the asynchronous operation to remove
     * @type {}
     * @memberof BuiltinApiHttpAsyncDelete
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * Request parameters for httpAsyncResult operation in BuiltinApi.
 * @export
 * @interface BuiltinApiHttpAsyncResultRequest
 */
export interface BuiltinApiHttpAsyncResultRequest {
    /**
     * ID of the asynchronous operation to check
     * @type {}
     * @memberof BuiltinApiHttpAsyncResult
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * Request parameters for httpAsyncStatus operation in BuiltinApi.
 * @export
 * @interface BuiltinApiHttpAsyncStatusRequest
 */
export interface BuiltinApiHttpAsyncStatusRequest {
    /**
     * ID of the asynchronous operation to check
     * @type {}
     * @memberof BuiltinApiHttpAsyncStatus
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * Request parameters for subscribe operation in BuiltinApi.
 * @export
 * @interface BuiltinApiSubscribeRequest
 */
export interface BuiltinApiSubscribeRequest {
    /**
     * Name of the event to subscribe to
     * @type {}
     * @memberof BuiltinApiSubscribe
     */
    readonly UNKNOWN_PARAMETER_NAME: any;

    /**
     * Desired format to receive events in. If unspecified, events will be sent in the active result format at the time.
     * @type {}
     * @memberof BuiltinApiSubscribe
     */
    readonly UNKNOWN_PARAMETER_NAME2?: any;
}

/**
 * Request parameters for unsubscribe operation in BuiltinApi.
 * @export
 * @interface BuiltinApiUnsubscribeRequest
 */
export interface BuiltinApiUnsubscribeRequest {
    /**
     * Name of the event to unsubscribe from
     * @type {}
     * @memberof BuiltinApiUnsubscribe
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * BuiltinApi - object-oriented interface
 * @export
 * @class BuiltinApi
 * @extends {BaseAPI}
 */
export class BuiltinApi extends BaseAPI implements BuiltinApiInterface {
    /**
     * 
     * @summary Cancels the asynchronous operation or removes its completion status.
     * @param {BuiltinApiAsyncDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public asyncDelete(requestParameters: BuiltinApiAsyncDeleteRequest, options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).asyncDelete(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the result of a completed asynchronous operation.
     * @param {BuiltinApiAsyncResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public asyncResult(requestParameters: BuiltinApiAsyncResultRequest, options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).asyncResult(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves details on the current state of an asynchronous operation.
     * @param {BuiltinApiAsyncStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public asyncStatus(requestParameters: BuiltinApiAsyncStatusRequest, options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).asyncStatus(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attempts to cancel an asynchronous operation
     * @param {BuiltinApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public cancel(requestParameters: BuiltinApiCancelRequest, options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).cancel(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Closes the connection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public exit(options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).exit(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * With no arguments, returns a list of all available functions and types along with a short description. If a function or type is specified, returns detailed information about it.
     * @summary Returns information on available functions and types
     * @param {BuiltinApiHelpRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public help(requestParameters: BuiltinApiHelpRequest = {}, options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).help(requestParameters.UNKNOWN_PARAMETER_NAME, requestParameters.UNKNOWN_PARAMETER_NAME2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the API declaration for a supported API
     * @param {BuiltinApiHttpApiDeclarationV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public httpApiDeclarationV1(requestParameters: BuiltinApiHttpApiDeclarationV1Request, options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).httpApiDeclarationV1(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the API documentation resource listing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public httpApiDocsV1(options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).httpApiDocsV1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the API documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public httpApiDocsV2(options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).httpApiDocsV2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the API documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public httpApiDocsV3(options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).httpApiDocsV3(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels the asynchronous operation or removes its completion status.
     * @param {BuiltinApiHttpAsyncDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public httpAsyncDelete(requestParameters: BuiltinApiHttpAsyncDeleteRequest, options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).httpAsyncDelete(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the result of a completed asynchronous operation.
     * @param {BuiltinApiHttpAsyncResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public httpAsyncResult(requestParameters: BuiltinApiHttpAsyncResultRequest, options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).httpAsyncResult(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves details on the current state of an asynchronous operation.
     * @param {BuiltinApiHttpAsyncStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public httpAsyncStatus(requestParameters: BuiltinApiHttpAsyncStatusRequest, options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).httpAsyncStatus(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Subscribes to a given event
     * @param {BuiltinApiSubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public subscribe(requestParameters: BuiltinApiSubscribeRequest, options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).subscribe(requestParameters.UNKNOWN_PARAMETER_NAME, requestParameters.UNKNOWN_PARAMETER_NAME2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unsubscribes from a given event
     * @param {BuiltinApiUnsubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuiltinApi
     */
    public unsubscribe(requestParameters: BuiltinApiUnsubscribeRequest, options?: RawAxiosRequestConfig) {
        return BuiltinApiFp(this.configuration).unsubscribe(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChampionsApi - axios parameter creator
 * @export
 */
export const ChampionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all data about the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayer: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/activeplayer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Abilities for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayerabilities: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/activeplayerabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of events that have occurred in the game
         * @param {} [UNKNOWN_PARAMETER_NAME] ID of the next event you expect to see
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataEventdata: async (UNKNOWN_PARAMETER_NAME?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/eventdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['eventID'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the list of heroes in the game and their stats
         * @param {} [UNKNOWN_PARAMETER_NAME] Heroes team ID. Optional, returns all players on all teams if null. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayerlist: async (UNKNOWN_PARAMETER_NAME?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/playerlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['teamID'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChampionsApi - functional programming interface
 * @export
 */
export const ChampionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChampionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all data about the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataActiveplayer(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataActiveplayer(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChampionsApi.getLiveclientdataActiveplayer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Abilities for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataActiveplayerabilities(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataActiveplayerabilities(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChampionsApi.getLiveclientdataActiveplayerabilities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of events that have occurred in the game
         * @param {} [UNKNOWN_PARAMETER_NAME] ID of the next event you expect to see
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataEventdata(UNKNOWN_PARAMETER_NAME?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataEventdata(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChampionsApi.getLiveclientdataEventdata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the list of heroes in the game and their stats
         * @param {} [UNKNOWN_PARAMETER_NAME] Heroes team ID. Optional, returns all players on all teams if null. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataPlayerlist(UNKNOWN_PARAMETER_NAME?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataPlayerlist(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChampionsApi.getLiveclientdataPlayerlist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChampionsApi - factory interface
 * @export
 */
export const ChampionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChampionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all data about the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayer(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataActiveplayer(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Abilities for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayerabilities(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataActiveplayerabilities(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of events that have occurred in the game
         * @param {ChampionsApiGetLiveclientdataEventdataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataEventdata(requestParameters: ChampionsApiGetLiveclientdataEventdataRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataEventdata(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the list of heroes in the game and their stats
         * @param {ChampionsApiGetLiveclientdataPlayerlistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayerlist(requestParameters: ChampionsApiGetLiveclientdataPlayerlistRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataPlayerlist(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChampionsApi - interface
 * @export
 * @interface ChampionsApi
 */
export interface ChampionsApiInterface {
    /**
     * 
     * @summary Get all data about the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChampionsApiInterface
     */
    getLiveclientdataActiveplayer(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Get Abilities for the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChampionsApiInterface
     */
    getLiveclientdataActiveplayerabilities(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Get a list of events that have occurred in the game
     * @param {ChampionsApiGetLiveclientdataEventdataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChampionsApiInterface
     */
    getLiveclientdataEventdata(requestParameters?: ChampionsApiGetLiveclientdataEventdataRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieve the list of heroes in the game and their stats
     * @param {ChampionsApiGetLiveclientdataPlayerlistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChampionsApiInterface
     */
    getLiveclientdataPlayerlist(requestParameters?: ChampionsApiGetLiveclientdataPlayerlistRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

}

/**
 * Request parameters for getLiveclientdataEventdata operation in ChampionsApi.
 * @export
 * @interface ChampionsApiGetLiveclientdataEventdataRequest
 */
export interface ChampionsApiGetLiveclientdataEventdataRequest {
    /**
     * ID of the next event you expect to see
     * @type {}
     * @memberof ChampionsApiGetLiveclientdataEventdata
     */
    readonly UNKNOWN_PARAMETER_NAME?: any;
}

/**
 * Request parameters for getLiveclientdataPlayerlist operation in ChampionsApi.
 * @export
 * @interface ChampionsApiGetLiveclientdataPlayerlistRequest
 */
export interface ChampionsApiGetLiveclientdataPlayerlistRequest {
    /**
     * Heroes team ID. Optional, returns all players on all teams if null. 
     * @type {}
     * @memberof ChampionsApiGetLiveclientdataPlayerlist
     */
    readonly UNKNOWN_PARAMETER_NAME?: any;
}

/**
 * ChampionsApi - object-oriented interface
 * @export
 * @class ChampionsApi
 * @extends {BaseAPI}
 */
export class ChampionsApi extends BaseAPI implements ChampionsApiInterface {
    /**
     * 
     * @summary Get all data about the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChampionsApi
     */
    public getLiveclientdataActiveplayer(options?: RawAxiosRequestConfig) {
        return ChampionsApiFp(this.configuration).getLiveclientdataActiveplayer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Abilities for the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChampionsApi
     */
    public getLiveclientdataActiveplayerabilities(options?: RawAxiosRequestConfig) {
        return ChampionsApiFp(this.configuration).getLiveclientdataActiveplayerabilities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of events that have occurred in the game
     * @param {ChampionsApiGetLiveclientdataEventdataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChampionsApi
     */
    public getLiveclientdataEventdata(requestParameters: ChampionsApiGetLiveclientdataEventdataRequest = {}, options?: RawAxiosRequestConfig) {
        return ChampionsApiFp(this.configuration).getLiveclientdataEventdata(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the list of heroes in the game and their stats
     * @param {ChampionsApiGetLiveclientdataPlayerlistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChampionsApi
     */
    public getLiveclientdataPlayerlist(requestParameters: ChampionsApiGetLiveclientdataPlayerlistRequest = {}, options?: RawAxiosRequestConfig) {
        return ChampionsApiFp(this.configuration).getLiveclientdataPlayerlist(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of events that have occurred in the game
         * @param {} [UNKNOWN_PARAMETER_NAME] ID of the next event you expect to see
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataEventdata: async (UNKNOWN_PARAMETER_NAME?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/eventdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['eventID'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of events that have occurred in the game
         * @param {} [UNKNOWN_PARAMETER_NAME] ID of the next event you expect to see
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataEventdata(UNKNOWN_PARAMETER_NAME?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataEventdata(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getLiveclientdataEventdata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of events that have occurred in the game
         * @param {EventsApiGetLiveclientdataEventdataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataEventdata(requestParameters: EventsApiGetLiveclientdataEventdataRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataEventdata(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - interface
 * @export
 * @interface EventsApi
 */
export interface EventsApiInterface {
    /**
     * 
     * @summary Get a list of events that have occurred in the game
     * @param {EventsApiGetLiveclientdataEventdataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    getLiveclientdataEventdata(requestParameters?: EventsApiGetLiveclientdataEventdataRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

}

/**
 * Request parameters for getLiveclientdataEventdata operation in EventsApi.
 * @export
 * @interface EventsApiGetLiveclientdataEventdataRequest
 */
export interface EventsApiGetLiveclientdataEventdataRequest {
    /**
     * ID of the next event you expect to see
     * @type {}
     * @memberof EventsApiGetLiveclientdataEventdata
     */
    readonly UNKNOWN_PARAMETER_NAME?: any;
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI implements EventsApiInterface {
    /**
     * 
     * @summary Get a list of events that have occurred in the game
     * @param {EventsApiGetLiveclientdataEventdataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getLiveclientdataEventdata(requestParameters: EventsApiGetLiveclientdataEventdataRequest = {}, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getLiveclientdataEventdata(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GameApi - axios parameter creator
 * @export
 */
export const GameApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Basic data about the game
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataGamestats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/gamestats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameApi - functional programming interface
 * @export
 */
export const GameApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GameApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Basic data about the game
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataGamestats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataGamestats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameApi.getLiveclientdataGamestats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GameApi - factory interface
 * @export
 */
export const GameApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GameApiFp(configuration)
    return {
        /**
         * 
         * @summary Basic data about the game
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataGamestats(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataGamestats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameApi - interface
 * @export
 * @interface GameApi
 */
export interface GameApiInterface {
    /**
     * 
     * @summary Basic data about the game
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApiInterface
     */
    getLiveclientdataGamestats(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

}

/**
 * GameApi - object-oriented interface
 * @export
 * @class GameApi
 * @extends {BaseAPI}
 */
export class GameApi extends BaseAPI implements GameApiInterface {
    /**
     * 
     * @summary Basic data about the game
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameApi
     */
    public getLiveclientdataGamestats(options?: RawAxiosRequestConfig) {
        return GameApiFp(this.configuration).getLiveclientdataGamestats(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of items for the player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayeritems: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('getLiveclientdataPlayeritems', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/liveclientdata/playeritems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['riotId'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of items for the player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataPlayeritems(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataPlayeritems(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getLiveclientdataPlayeritems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of items for the player
         * @param {ItemsApiGetLiveclientdataPlayeritemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayeritems(requestParameters: ItemsApiGetLiveclientdataPlayeritemsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataPlayeritems(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - interface
 * @export
 * @interface ItemsApi
 */
export interface ItemsApiInterface {
    /**
     * 
     * @summary Retrieve the list of items for the player
     * @param {ItemsApiGetLiveclientdataPlayeritemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApiInterface
     */
    getLiveclientdataPlayeritems(requestParameters: ItemsApiGetLiveclientdataPlayeritemsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

}

/**
 * Request parameters for getLiveclientdataPlayeritems operation in ItemsApi.
 * @export
 * @interface ItemsApiGetLiveclientdataPlayeritemsRequest
 */
export interface ItemsApiGetLiveclientdataPlayeritemsRequest {
    /**
     * RiotID GameName (with tag) of the player in the format Name#TAG
     * @type {}
     * @memberof ItemsApiGetLiveclientdataPlayeritems
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI implements ItemsApiInterface {
    /**
     * 
     * @summary Retrieve the list of items for the player
     * @param {ItemsApiGetLiveclientdataPlayeritemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getLiveclientdataPlayeritems(requestParameters: ItemsApiGetLiveclientdataPlayeritemsRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getLiveclientdataPlayeritems(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunesApi - axios parameter creator
 * @export
 */
export const RunesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the full list of runes for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayerrunes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/activeplayerrunes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the basic runes of any player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayermainrunes: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('getLiveclientdataPlayermainrunes', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/liveclientdata/playermainrunes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['riotId'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunesApi - functional programming interface
 * @export
 */
export const RunesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the full list of runes for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataActiveplayerrunes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataActiveplayerrunes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunesApi.getLiveclientdataActiveplayerrunes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the basic runes of any player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataPlayermainrunes(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataPlayermainrunes(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunesApi.getLiveclientdataPlayermainrunes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunesApi - factory interface
 * @export
 */
export const RunesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunesApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the full list of runes for the active player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataActiveplayerrunes(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataActiveplayerrunes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the basic runes of any player
         * @param {RunesApiGetLiveclientdataPlayermainrunesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayermainrunes(requestParameters: RunesApiGetLiveclientdataPlayermainrunesRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataPlayermainrunes(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunesApi - interface
 * @export
 * @interface RunesApi
 */
export interface RunesApiInterface {
    /**
     * 
     * @summary Retrieve the full list of runes for the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunesApiInterface
     */
    getLiveclientdataActiveplayerrunes(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

    /**
     * 
     * @summary Retrieve the basic runes of any player
     * @param {RunesApiGetLiveclientdataPlayermainrunesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunesApiInterface
     */
    getLiveclientdataPlayermainrunes(requestParameters: RunesApiGetLiveclientdataPlayermainrunesRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

}

/**
 * Request parameters for getLiveclientdataPlayermainrunes operation in RunesApi.
 * @export
 * @interface RunesApiGetLiveclientdataPlayermainrunesRequest
 */
export interface RunesApiGetLiveclientdataPlayermainrunesRequest {
    /**
     * RiotID GameName (with tag) of the player in the format Name#TAG
     * @type {}
     * @memberof RunesApiGetLiveclientdataPlayermainrunes
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * RunesApi - object-oriented interface
 * @export
 * @class RunesApi
 * @extends {BaseAPI}
 */
export class RunesApi extends BaseAPI implements RunesApiInterface {
    /**
     * 
     * @summary Retrieve the full list of runes for the active player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunesApi
     */
    public getLiveclientdataActiveplayerrunes(options?: RawAxiosRequestConfig) {
        return RunesApiFp(this.configuration).getLiveclientdataActiveplayerrunes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the basic runes of any player
     * @param {RunesApiGetLiveclientdataPlayermainrunesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunesApi
     */
    public getLiveclientdataPlayermainrunes(requestParameters: RunesApiGetLiveclientdataPlayermainrunesRequest, options?: RawAxiosRequestConfig) {
        return RunesApiFp(this.configuration).getLiveclientdataPlayermainrunes(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScoresApi - axios parameter creator
 * @export
 */
export const ScoresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of the current scores for the player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayerscores: async (UNKNOWN_PARAMETER_NAME: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'UNKNOWN_PARAMETER_NAME' is not null or undefined
            assertParamExists('getLiveclientdataPlayerscores', 'UNKNOWN_PARAMETER_NAME', UNKNOWN_PARAMETER_NAME)
            const localVarPath = `/liveclientdata/playerscores`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['riotId'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScoresApi - functional programming interface
 * @export
 */
export const ScoresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScoresApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of the current scores for the player
         * @param {} UNKNOWN_PARAMETER_NAME RiotID GameName (with tag) of the player in the format Name#TAG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataPlayerscores(UNKNOWN_PARAMETER_NAME: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataPlayerscores(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScoresApi.getLiveclientdataPlayerscores']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScoresApi - factory interface
 * @export
 */
export const ScoresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScoresApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of the current scores for the player
         * @param {ScoresApiGetLiveclientdataPlayerscoresRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayerscores(requestParameters: ScoresApiGetLiveclientdataPlayerscoresRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataPlayerscores(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScoresApi - interface
 * @export
 * @interface ScoresApi
 */
export interface ScoresApiInterface {
    /**
     * 
     * @summary Retrieve the list of the current scores for the player
     * @param {ScoresApiGetLiveclientdataPlayerscoresRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoresApiInterface
     */
    getLiveclientdataPlayerscores(requestParameters: ScoresApiGetLiveclientdataPlayerscoresRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

}

/**
 * Request parameters for getLiveclientdataPlayerscores operation in ScoresApi.
 * @export
 * @interface ScoresApiGetLiveclientdataPlayerscoresRequest
 */
export interface ScoresApiGetLiveclientdataPlayerscoresRequest {
    /**
     * RiotID GameName (with tag) of the player in the format Name#TAG
     * @type {}
     * @memberof ScoresApiGetLiveclientdataPlayerscores
     */
    readonly UNKNOWN_PARAMETER_NAME: any;
}

/**
 * ScoresApi - object-oriented interface
 * @export
 * @class ScoresApi
 * @extends {BaseAPI}
 */
export class ScoresApi extends BaseAPI implements ScoresApiInterface {
    /**
     * 
     * @summary Retrieve the list of the current scores for the player
     * @param {ScoresApiGetLiveclientdataPlayerscoresRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScoresApi
     */
    public getLiveclientdataPlayerscores(requestParameters: ScoresApiGetLiveclientdataPlayerscoresRequest, options?: RawAxiosRequestConfig) {
        return ScoresApiFp(this.configuration).getLiveclientdataPlayerscores(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UnitsApi - axios parameter creator
 * @export
 */
export const UnitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of heroes in the game and their stats
         * @param {} [UNKNOWN_PARAMETER_NAME] Heroes team ID. Optional, returns all players on all teams if null. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayerlist: async (UNKNOWN_PARAMETER_NAME?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/liveclientdata/playerlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (UNKNOWN_PARAMETER_NAME !== undefined) {
                localVarQueryParameter['teamID'] = UNKNOWN_PARAMETER_NAME;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnitsApi - functional programming interface
 * @export
 */
export const UnitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UnitsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of heroes in the game and their stats
         * @param {} [UNKNOWN_PARAMETER_NAME] Heroes team ID. Optional, returns all players on all teams if null. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveclientdataPlayerlist(UNKNOWN_PARAMETER_NAME?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiveclientdataPlayerlist(UNKNOWN_PARAMETER_NAME, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UnitsApi.getLiveclientdataPlayerlist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UnitsApi - factory interface
 * @export
 */
export const UnitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UnitsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of heroes in the game and their stats
         * @param {UnitsApiGetLiveclientdataPlayerlistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveclientdataPlayerlist(requestParameters: UnitsApiGetLiveclientdataPlayerlistRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.getLiveclientdataPlayerlist(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UnitsApi - interface
 * @export
 * @interface UnitsApi
 */
export interface UnitsApiInterface {
    /**
     * 
     * @summary Retrieve the list of heroes in the game and their stats
     * @param {UnitsApiGetLiveclientdataPlayerlistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApiInterface
     */
    getLiveclientdataPlayerlist(requestParameters?: UnitsApiGetLiveclientdataPlayerlistRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }>;

}

/**
 * Request parameters for getLiveclientdataPlayerlist operation in UnitsApi.
 * @export
 * @interface UnitsApiGetLiveclientdataPlayerlistRequest
 */
export interface UnitsApiGetLiveclientdataPlayerlistRequest {
    /**
     * Heroes team ID. Optional, returns all players on all teams if null. 
     * @type {}
     * @memberof UnitsApiGetLiveclientdataPlayerlist
     */
    readonly UNKNOWN_PARAMETER_NAME?: any;
}

/**
 * UnitsApi - object-oriented interface
 * @export
 * @class UnitsApi
 * @extends {BaseAPI}
 */
export class UnitsApi extends BaseAPI implements UnitsApiInterface {
    /**
     * 
     * @summary Retrieve the list of heroes in the game and their stats
     * @param {UnitsApiGetLiveclientdataPlayerlistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApi
     */
    public getLiveclientdataPlayerlist(requestParameters: UnitsApiGetLiveclientdataPlayerlistRequest = {}, options?: RawAxiosRequestConfig) {
        return UnitsApiFp(this.configuration).getLiveclientdataPlayerlist(requestParameters.UNKNOWN_PARAMETER_NAME, options).then((request) => request(this.axios, this.basePath));
    }
}



